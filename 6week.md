[be back](https://github.com/ToMikhail/andersen)


# 36. RxJx. Operators (required level 3)

**level 1:**  

- What is Observable;
  -   RxJS представляет собой библиотеку, позволяющую управлять всеми асинхронными операциями и событиями в приложении в стиле реактивного программирования. Мы можем подписаться на stream и отлавливать све что происходит с этим стриомом (все изменения)
  
    - Observable;
    > Объекты RxJS Observable создаются либо с использованием операторов создания (of, from, fromEvent), либо через конструктор new Observable.

    Пример с оператором of().

    ```
      of('Hello').subscribe((vl) => console.log(vl));
    ```
    Пример с new Observable.

    ```
      const obs = new Observable((sub) => {
        sub.next(1);

        setTimeout(() => {
          sub.next(3);
          sub.complete();
        }, 500);
      });

      obs.subscribe((vl) => console.log(vl));
      ```
- What is Subject;
      Subject является разновидностью объектов Observable. Особенность Subject в том, что он может отправлять данные одновременно множеству "потребителей" (multicasetd), которые могут регистрироваться уже в процессе исполнения Subject, в то время как исполнение стандартного Observable осуществляется уникально (uniquecasted) для каждого его вызова.   
      >Объекты RxJS Subject реализуют принцип работы событий, поддерживая возможность регистрировать неограниченное количество обработчиков отправляемых ими данных.   
      ```
        const sbj = new Subject<number>();

        sbj.subscribe((vl) => console.log(`1st: ${vl}`));
        sbj.next(3);
        sbj.subscribe((vl) => console.log(`2nd: ${vl}`));
        sbj.next(9);

        /*
        Результат  в консоли:

        1st: 3
        1st: 9
        2nd: 9
      */
      ```

- Promise vs Observable - Promise выполнили один раз и уничтожили данные, Observable - это стрим , кторый можно использовать много раз.;
- Pipe operator- может вызываться для одной или нескольких функций, каждая из которых может принимать один аргумент ("UnaryFunction") и использовать его для возврата значения.;
- Name a few operators that you have used (take(), takeWhile(), takeUntill(), tap(), of(), from(), fromEvent(), interval(), filter(), map(), reduce(), catchError(), retry(), delay() 

**level 2:**  

- Types of Subjects;
    В RxJS имеется несколько разновидностей Subject:    
    >  - BehaviorSubject -  хранит в себе последнее отправленное им значение. Так, каждому новому обработчику в момент регистрации (вызов subscribe()) будет отправлено >это значение;   
    >  - ReplaySubject - в отличие от BehaviorSubject объекты ReplaySubject способны хранить заданное количество последних значений, которое задается при создании >объекта;   
    >  - AsyncSubject - в случае с AsyncSubject "потребителям" передается только последнее значение объекта и только, когда он завершит свое выполнение (вызов >complete());   
    >  - AvoidSubject - если не надо выбаваить ничего а сообщить что стрим закончился (пример).
- What do you need to unsubscribe from, and why not - memory leacks - потери памяти при неиспользуемом стриме;
- What types of unsubscriptions do you know;
  1. Отписаться от стрима через метод unsubscribe()[https://blog.bitsrc.io/6-ways-to-unsubscribe-from-observables-in-angular-ab912819a78f];
  1. Опрераторы take() и first():     
  * take(num) - где num - это количество получаемых входных данных;
  * takeUntil(notifier) => nitifier = new subject() и в методе ngOnDestroy{ notifier.next() и notifier.complete() };
  * takeWhile(val => val < 5);
  * first() - если без аргументов то выдаст первое приходящее значение. если first(val => val === 5) - получим только 5.
  * 
- Difference between takeWhile and takeUntil;
  - Используйте takeUntil, когда какое-то внешнее событие указывает на то, что пришло время отказаться от подписки. 
  - Используйте takeWhile, когда входящее значение достигает условия, определенного для отказа от подписки.
- What are the operators of:   
  - creation(of(), for(), fromEvent()), 
  - combination (joinFork() - оператор лучше всего использовать, когда у вас есть группа наблюдаемых и вас интересует только конечное испускаемое значение каждого из них. Один из распространенных вариантов использования этого — если вы хотите отправить несколько запросов при загрузке страницы (или каком-то другом событии) и хотите действовать только после получения ответа для всех. Таким образом, это похоже на то, как вы можете использовать Promise.all.  zip()  - выдаст массив знаений после получения последнего); CombineLatest(streams$) - выдаст массив последних значений стримов при выдаче одного из них) 
  - transformation(map(), filter(), ), 
  - error handling (catchError(), retry());

**level 3:**  

- What is hot, what is cold observable;
  ***Cold Observable (lazy) (unicated)*** - начинают передовать данные только когда мы подпишимся(выполним метод subscribe()) на них. Каждый subscribe() создает отдельный контекст выполнения Observable (пример с получением Math.random - каждый subscribe() вернет разное значение). Создает и активирует данные в Observable;  
  ***Hot observeable (multycasted)*** - получают данные всегда, независмо сделали мы подписку или нет (subscribe()). Создает и активирует данные вне Observable;   
  ***Warm observeable (подогретый)*** - cold observable можно подогреть. Используя оператор multicasted() куда мы передвем Subject(). Затем объединяем два стрима с помощью метожа connect();   
- How to make hot from cold (multicasted, lazy - не рабаотет без cubscribe() ) - через использование операторов share(), publish();
- Difference between withLatesFrom, zip, combineLatest, forkJoin, exhaustMap, switchMap, mergeMap;
- Operators multicast, publish, publishReplay, PublishLast, share;

**level 4:** 

- Observable/observer as a software desing pattern - асинхронный паттерн проектирования, в котором данные представлены в виде потока событий. Потоки можно «переиспользовать» – комбинировать, фильтровать, подобно массивам, используя специальные методы – операторы. Паттерн Observable, в отличие от них, является «макро-паттерном» и позволяет вынести логику обработки и управления асинхронными событиями на отдельный слой приложения. 

---


# 37. Angular.Change Detection (required level 4)

**level 1:**  

- What is change detection and why is it needed? -это стратегия, с помощью которой Angular решает, какие действия следует выполнять при изменении состояния приложения или компонента.
- Types of change detection strategies;
  - ChangeDetectionStrategy.Default - По умолчанию Angular не делает никаких предположений о том, от чего зависит компонент. Таким образом, он должен быть консервативным и проверять каждый раз, когда что-то могло измениться, это называется грязной проверкой. Более конкретно, он будет выполнять проверки для каждого события браузера, таймеров, XHR и промисов. Это может быть проблематично, когда вы начинаете создавать большое приложение со многими компонентами, особенно если вы сосредоточены на производительности.
  - OnPush - в основном говорите Angular, что он не должен делать никаких предположений о том, когда ему нужно выполнить проверку на наличие изменений. Он будет полагаться только на изменение входных ссылок, некоторые события, инициированные им самим (компонентом) или одним из его дочерних элементов. Наконец, вы, разработчик, можете явно попросить Angular сделать это с помощью метода componentRef.markForCheck().

**level 2:**  

- Difference between strategies OnPush vs Default;
    - Default инициируется проверка при любых изменениях системы (input, event, async, setTimeOut, Observable). Проверятются все компоненты;
    - OnPush - порверяются при    
      1. изменениях ссылок на объект(input), 
      2. events - пользовательские   
      3. Вручную: 
         - DetectChanges() - запускает проверку на этом и н аслед вниз по дереву компонентах
         - componentRef.markForCheck()() - запускается вверхх по дереву при след рендеринге, включая этот элемент;
         - ApplicationRefTick() - инициирует порверку всего приложения (вручную особо не используется)
- What are the triggers for launching change detection for the OnPush strategy;

**level 3:**  

- marckForCheck vs detectChanges - markForCheck помечает компонент и его дочерние элементы для проверки в следующем цикле вверх по дереву, а detectChanges — фактически сразу запускает механизм обнаружения изменений;
  - cd.detectChanges() немедленно запускает обнаружение изменений от текущего компонента до его потомков.
  - cd.markForCheck() не будет запускать обнаружение изменений, но пометит своих предков как нуждающихся в запуске обнаружения изменений. В следующий раз, когда обнаружение изменений запустится где угодно, оно будет запущено и для тех компонентов, которые были отмечены.
  - https://www.youtube.com/watch?v=OcphK_aEd7I 
- Application.tick vs detectChanges;
  - Application.tick - этот метод для явной обработки обнаружения изменений и его побочных эффектов.
  - **Application.tick** - запускается с root предвставления,** detectChanges()** - запускается с компонента его вызвавшего вниз по дереву

**level 4:** 

- detach(), checkNoChanges(), reattach() - ChangeDetectorRef - Базовый класс, обеспечивающий функциональность обнаружения изменений. Дерево обнаружения изменений собирает все представления, которые необходимо проверить на наличие изменений. Используйте методы, чтобы добавлять и удалять представления из дерева, инициировать обнаружение изменений и явно помечать представления как грязные, что означает, что они изменились и должны быть повторно отображены. абстрактный класс;
  - detach() - Отсоединяет это представление от дерева обнаружения изменений. Отсоединенный вид не проверяется до тех пор, пока он не будет повторно присоединен. Используйте в сочетании с detectChanges() для реализации проверок обнаружения локальных изменений.
  - checkNoChanges() - Проверяет детектор изменений и его дочерние элементы и сбрасывает, если обнаруживаются какие-либо изменения.
  - reattach() - Повторно прикрепляет ранее отсоединенное представление к дереву обнаружения изменений. Представления прикреплены к дереву по умолчанию.
- Architectural advantages of both of strategies;
  - ChangeDetectionStrategy.Default - По умолчанию Angular не делает никаких предположений о том, от чего зависит компонент. Таким образом, он должен быть консервативным и проверять каждый раз, когда что-то могло измениться, это называется грязной проверкой. Более конкретно, он будет выполнять проверки для каждого события браузера, таймеров, XHR и промисов. Это может быть проблематично, когда вы начинаете создавать большое приложение со многими компонентами, особенно если вы сосредоточены на производительности.
  - OnPush - в основном говорите Angular, что он не должен делать никаких предположений о том, когда ему нужно выполнить проверку на наличие изменений. Он будет полагаться только на изменение входных ссылок, некоторые события, инициированные им самим (компонентом) или одним из его дочерних элементов. Наконец, вы, разработчик, можете явно попросить Angular сделать это с помощью метода componentRef.markForCheck().

---


# 38. Angular.Change Detection.ngZone (required level 2)

**level 1:**  

- What is zone.js?
  - zone — это контекст выполнения, который сохраняется для асинхронных задач. Вы можете думать об этом как о локальном хранилище потока для виртуальной машины JavaScript. 
  - https://medium.com/@overthesanity/zone-js-%D0%BE%D1%82-%D0%B0-%D0%B4%D0%BE-%D1%8F-fdb995917968
  - https://www.youtube.com/watch?v=KVeX7oKQxlQ
  - https://www.youtube.com/watch?v=rc3E4tplFCU&t=2964s
  - https://www.youtube.com/watch?v=7LLnPxP8Txw

**level 2:**  

- Zone hooks
  - onScheduleTask - Запускается, когда планируется новая асинхронная задача, например, когда вы вызываете setTimeout().
  - onInvokeTask - Запускается, когда собирается запуститься асинхронная задача, например, когда собирается выполнить обратный вызов setTimeout().
  - onHasTask - Срабатывает, когда статус задачи одного типа внутри зоны изменяется со стабильного на нестабильный или с нестабильного на стабильный. Статус «стабильный» означает, что в зоне нет задач, а «нестабильный» означает, что в зоне запланирована новая задача.
  - onInvoke - Срабатывает, когда в зоне будет выполняться синхронная функция.

**level 3:**  

- run/runOutsideAngular -По умолчанию все асинхронные операции находятся внутри зоны Angular, что автоматически запускает обнаружение изменений.
  - ngZone.run() - позволяет запускать функцию внутри зоны Angular. Эта функция и все асинхронные операции в этой функции автоматически запускают обнаружение изменений в нужное время.
  - runOutsideAngular() - когда вы не хотите инициировать обнаружение изменений. В этой ситуации вы можете использовать другой метод NgZone: runOutsideAngular().

**level 4:** 

- noop Zone; - Чтобы удалить Zone.js, внесите следующие изменения и Bootstrap Angular с зоной noop в src/main.ts
```
platformBrowserDynamic().bootstrapModule(AppModule, { ngZone: 'noop' })
.catch(err => console.error(err));
```

---

# 39. Angular. Dependency Injection (required level 3)

**level 1:**  

- What is Dependency Injection and why is it needed? 
  - В проектировании программного обеспечения объектно-ориентированного программирования (ООП) внедрение зависимостей (DI) — это процесс предоставления ресурса, который требуется для данного фрагмента кода. DI подключен к фреймворку Angular и позволяет классам с декораторами Angular, такими как компоненты, директивы, конвейеры и инъекционные элементы, настраивать необходимые им зависимости.
- The main components of Dependency Injection (Dependency, Injector, Provider)
  - Dependency - это Injection Token (unique) и привязываемая сущность (класс) 
  - Injector - это Объект в системе внедрения зависимостей Angular, который может найти именованную зависимость в своем кеше или создать зависимость с помощью настроенного провайдера. Инжекторы создаются для NgModules автоматически как часть процесса начальной загрузки и наследуются через иерархию компонентов.
  - Provider - Объект (как создать класс), реализующий один из интерфейсов Provider. Объект поставщика определяет, как получить внедряемую зависимость, связанную с токеном DI. Инжектор использует провайдера для создания нового экземпляра зависимости для класса, который в ней нуждается.
- What can Dependency be? - гибкая архитектура, нет дублирования кода.
- What is Injector? - это Объект в системе внедрения зависимостей Angular, который может найти именованную зависимость в своем кеше или создать зависимость с помощью настроенного провайдера. Инжекторы создаются для NgModules автоматически как часть процесса начальной загрузки и наследуются через иерархию компонентов.
- What is a Provider? - Объект (как создать класс), реализующий один из интерфейсов Provider. Объект поставщика определяет, как получить внедряемую зависимость, связанную с токеном DI. Инжектор использует провайдера для создания нового экземпляра зависимости для класса, который в ней нуждается.

**level 2:**  

- How many injectors are there and how are they located? (In an Angular application, there can be several of these injectors, they are located in a tree hierarchy parallel to the component tree)
  Injecot null   
      ||   
 Platform module Injector
      ||
  Injector App(root)   
      ||  
 Module Injector   
      ||
 Element Injector  
 
- What are the ways to provide a dependency to the injector (providers, viewProviders, @Injectable)?
  - Добавить в массив providers[] в NgModule в Модуль или добавить в модуль через @injectable {provideIn: root} <= 2 пвть предпочтительнее потому что tree shacking работаетж
  - Задать его отдельно для component в providers или viewProviders [provider: token, useClass or useExisting or useFactory, useValue]
- What defines a provider? - как мы будем использовать зависимость, useClass (как отдельный инстенс) or useExisting(для использования не всех возможностей класса) or useFactory (ф-ция с несколькоими сервисами), useValue (больше для тестирования =  new Token  Injection)

**level 3:**  

- @Inject () and @Injectable () what is the difference?
  - @Inject() это ручной механизм, позволяющий Angular узнать, что параметр должен быть введен. Его можно использовать так:
  ```
   constructor(@Inject(ChatWidget) private chatWidget) { }
   }
  ```
  - @Injectable() сообщает Angular, что класс можно использовать с инжектором зависимостей. @Injectable() строго не требуется, если класс имеет другие декораторы Angular или не имеет никаких зависимостей. Важно то, что любой класс, который будет внедрен с помощью Angular, украшен. Тем не менее, лучше всего украшать инъекционные объекты с помощью @Injectable(), так как это имеет больше смысла для читателя.
  
- What is useClass, useValue, useFactory, useExisting 
  - Angular Dependency Injection предоставляет несколько типов провайдеров.
  ```
   providers :[{ provide: ProductService, useClass: ProductService }]
  ```
    - useClass - если вы хотите предоставить экземпляр предоставленного класса.
    - useValue -  если вы хотите предоставить простое значение.
    - useFactory - ожидает, что мы предоставим функцию. Он вызывает функцию и вводит возвращаемое значение. Мы также можем добавить необязательные аргументы в    фабричную функцию, используя массив deps. Массив deps указывает, как вводить аргументы.
    - useExisting - если вы хотите использовать нового поставщика вместо старого поставщика.
- How does Angular look for a supplier in the injector hierarchy?
- What are viewProviders? - ViewProviders похожи на Providers, за исключением того, что определяемые вами зависимости видны только дочерним элементам представления. Они не видны дочерним элементам содержимого (content children - для ng-content).

**level 4:** 

- Why do we need @Optional, @Host, @Self, @SkipSelf decorators
  - @Optional -  считать внедряемый вами сервис необязательным. Таким образом, если это не может быть разрешено во время выполнения, Angular разрешает службу как null, а не выдает ошибку. 
  - @Self - Angular будет смотреть на ElementInjector только для текущего компонента или директивы.
  - @SkipSelf -Angular начинает поиск службы в родительском ElementInjector.
  - @Host - позволяет указать компонент как последнюю остановку в дереве инжекторов при поиске поставщиков. Даже если есть экземпляр службы выше по дереву, Angular не будет продолжать искать Use @Host() 
  
- flag multi: true why is it?
  - Использование multi: true сообщает Angular, что провайдер является мультипровайдером. Как упоминалось ранее, с несколькими поставщиками мы можем предоставить несколько значений для одного токена в DI. Это именно то, что мы делаем. У нас есть два провайдера, у обоих один и тот же токен, но они предоставляют разные значения. Если мы запросим зависимость для этого токена, мы получим список всех зарегистрированных и предоставленных значений.
  
- What are tree-shakable providers? - Одноэлементная служба создается при первом создании любого компонента, зависящего от нее. Считается лучшей практикой всегда украшать службу на основе классов с помощью Injectable .
- Handmade injector;

---


# 40. Angular. Extra. CLI (required level 2)

**level 1:**  

**level 2:**  

**level 3:**  

- generate, add, build, serve etc
  - ng new - Команда создает папку рабочей области Angular и генерирует новый скелет приложения.
  - ng config - позволяет вам устанавливать и получать значения конфигурации из командной строки, или вы можете напрямую редактировать файл angular.json.
  - add - Добавляет поддержку внешней библиотеки в ваш проект.
  - serve - Создает и обслуживает ваше приложение, перестраивая изменения файлов.
  - test	t - Запускает модульные тесты в проекте.
  - build - Компилирует приложение или библиотеку Angular в выходной каталог с именем dist/ по указанному выходному пути.
  - config - Извлекает или задает значения конфигурации Angular в файле angular.json для рабочей области.
  - deploy - Вызывает построитель развертывания для указанного проекта
  - generate	g - generete
  - lint - Запускает инструменты анализа кода приложения Angular в заданной папке проекта.

**level 4:**   

- angular.json. What is it about
  - Файл angular.json на корневом уровне рабочей области Angular предоставляет настройки по умолчанию для всей рабочей области и для конкретного проекта. Они используются для инструментов сборки и разработки, предоставляемых Angular CLI. Значения пути, указанные в конфигурации, относятся к корневому каталогу рабочей области.

---

# 41. Angular. Extra. Ivy (required level 2)

**level 1:**  

**level 2:**  

**level 3:**  

**level 4:** 

- What is Ivy?
  - Это движок для рендеринга. это кодовое название next-generation compilation and rendering pipeline. В версии 9 Angular по умолчанию используются новые инструкции компилятора и среды выполнения вместо старых компилятора и среды выполнения, известных как View Engine.
  - https://www.youtube.com/watch?v=8fUKZm6WOxY
    - Уменьшение бандлов (15%)
    - появилась поддержка tree shaking;
    - улуч тестинг - ошибки четче
    - усорилось запуск тестов
    - поддурка typeScipt
    - 

---

