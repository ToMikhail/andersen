[be back](https://github.com/ToMikhail/andersen)


# 48. Angular. Testing. Unit (required level 3)

**level 1:**  
-

**level 2:**  

- Test bed. Why do we need it?
> является основным API для написания модульных тестов для приложений и библиотек Angular. Настраивает и инициализирует среду для модульного тестирования и предоставляет методы для создания компонентов и служб в модульных тестах.   
> Как один из метод решения проблемы тестов компонента с зависимостями. TestBed - это инструмент от Anguar, кторый создает тестовое окружение (тестовый модуль).
TestBed

   * 1-й вариант замокать зависимость   
 > Kак вариант сделать заглушку зависимости, это создание объекта и передать туда методы для зависимости и добавить это все в TestBed.ConfigureTestingModule  
  ```
  TestBed.ConfigureTestingModule (
  { provieder: [TestingService], 
    { provide: FirstDepService, useValue: fakeObj }
  ```
  * 2-й вариант замокать зависимость 
 > Создать в fakeObj метод через jasmine.createSpy()   
  ```
  const fakeObj = {
    returnValue: jasmine.createSpy('returnSpy')
  }
  ```
  
   * 3-й вариант замокать зависимость(самый удобный и быстрый способ)
 > Создать в fakeObj метод через jasmine.createSpyObject() и добавить fakeObj в useValue в TestBed.ConfigureTestingModule
  ```
  const fakeObj = jasmine.createSpyObject(массив с названеим методов с необходимыми зависимостями)
  ```

**level 3:**  

- Testing components/services
   - https://angular.io/guide/testing-components-scenarios
   - https://angular.io/guide/testing-services

  > В компоненте необходимо тестировать шаблон и сам класс.   
  > В шаблон необходимо тестировать какие то сложные вещи (контен не надо!), привязку данных, тестирование директив   
  > Что бы получить доступ к элментоу DOM, необбходимо использовать ***debugElemen.querry(By.css('h1'))***   
  > В классе компонента необходимо тесчтировать все public methods, private methods -тестировать не надо. Но если возникает такая необходимость то сделать метод не private a public.

**level 4:** 

- Testing directives;
  - https://angular.io/guide/testing-attribute-directives
  
- Testing pipes;
  - https://angular.io/guide/testing-pipes

---

# 49. Angular. Extra. AoT / JIT (required level 2)
  
  - https://angular.io/guide/aot-compiler
  - https://angdev.ru/doc/angular-compilation/

**level 1:**  
-

**level 2:**  
-

**level 3:**  

- Basic difference for both compilations
  - https://www.geeksforgeeks.org/what-is-aot-and-jit-compiler-in-angular/
>Поскольку разработка ведется на TypeScript, то для запуска в браузере приложение должно быть предварительно обработано компилятором Angular, который конвертирует код исходных файлов в исполняемый JavaScript.
>Механизм Angular compile реализован в двух режимах:

    - JIT-компиляция (Just-in-TIme);
    - AOT-компиляция (Ahead-of-Time).
    
>В режиме JIT (используется по умолчанию) приложение компилируется в момент его запуска в браузере. В режиме AOT компиляция происходит в момент сборки приложения. Для этого при выполнении некоторых CLI-команд необходимо указать флаг --aot. 
>При сборке приложения с флагом --prod AOT-компиляция используется по умолчанию.

  Преимущества Angular AOT:    
  
    - Быстрая загрузка в браузере. Меньше времени тратится за счет того, что:    
    - Приложение компилируется до загрузки в браузер;    
    - В сборку не включается компилятор Angular и, как следствие, конечные файлы имеют меньший размер;    
    - Выполняется меньше AJAX-запросов на получение исходных HTML- и CSS-файлов, поскольку они включаются в строковом виде в файлы JavaScript.   
    - Обнаружение ошибок при сборке. Имеется возможность исправить все ошибки до запуска приложения в режиме эксплуатации.    
    - Повышенная безопасность.Поскольку HTML- и CSS-файлы включаются в процессе Angular compile в файлы JavaScript, то нет возможности просмотреть шаблоны, что снижает риск осуществления атак.

**level 4:**  

- Template build for AoT;
- AoT compilation phases:  

    * Code analysis (Анализ) - В процессе анализа формируются данные, необходимые для генерации кода. Это файлы определения типов (*.d.ts) и файлы, содержащие информацию о метаданных, указанных в декораторах (*.metadata.json). Также процесс анализа включает в себя некоторую оптимизацию кода.
    * Code generation (Генерация кода) - На этой стадии интерпретируются все файлы, сгенерированные на стадии анализа. Отдельно стоит упомянуть проверку модификаторов доступа свойств классов. Например, если свойство определено как private и используется в шаблоне, то будет сгенерирована соответствующая ошибка.
    *	Template type checking (Валидация) - На стадии валидации компилятор шаблонов использует компилятор TypeScript для проверки правильности использования свойств и методов компонентов и сервисов в шаблонах.

---

# 50. Angular. Extra. External tools (required level 2)

https://angdev.ru/ngrx/about/#reducers
https://ngrx.io/docs
https://habr.com/ru/post/489674/

>NgRx — это фреймворк для создания реактивных приложений в Angular (вдохнавленный от redux).    
>Redux — это инструмент для управления состоянием данных и пользовательским интерфейсом в приложениях JavaScript с большим количеством сущностей. Представляет собой библиотеку JavaScript.
>Название читается как «Редакс» и составлено из двух слов: reduce и flux. Reduce — это функция, которая приводит большую структуру данных к одному значению. Flux — архитектура приложения, при которой данные передаются в одну сторону. Инструмент основан на этих двух понятиях, поэтому они вынесены в название.
> NgRx предоставляет библиотеки для:   
>  - Управление глобальным и локальным состоянием.    
>  - Изоляция побочных эффектов для продвижения более чистой архитектуры компонентов.   
>  - Управление коллекцией сущностей. Интеграция с Angular Router.    
>  - Инструменты разработчика, которые расширяют возможности разработчиков при создании различных типов приложений.

Packages - Пакеты NgRx делятся на несколько основных категорий: 

  - State
  - Data
  - View
  - Developer Tools

>Основной целью этой схемы является обеспечение предсказуемого состояния контейнера, основанного на трех основных принципах:
>- Единственный источник правды - В случае с архитектурой redux/ngrx это означает, что состояние всего вашего приложения хранится в дереве объектов в пределах одного хранилища.
>- Состояние только для чтения - Вы никогда не изменяете состояние (state) напрямую, вместо этого вы отправляете действия (dispatch actions). Эти действия описывают, что происходит
>- Изменения делаются чистыми функциями - Операция, инициируемая отправкой действия, будет чистой функцией, называемой в архитектуре redux — reducer (редукторами).
Эти редукторы (просто чистые функции) получают действие (action) и состояние (state), в зависимости от отправленного действия (обычно отфильтрованного оператором switch), они выполняют операцию и возвращают новый объект состояния.
 
**level 1:**  
-

**level 2:**  
-

**level 3:**  
- tslinter/eslinter. Angular and rxjs main linter rules
  - https://cartant.github.io/rxjs-tslint-rules/
  - @angular-eslint/component-class-suffix
  - "@angular-eslint/component-selector"
  - "@angular-eslint/directive-class-suffix"

>Используйте ESLint, чтобы следовать рекомендациям и избегать распространенных ошибок в приложении.

>Плагин NgRx ESLint ничем не отличается и продвигает ключевые концепции для создания поддерживаемого проекта. Он состоит из правил:
  - @ngrx/store,  
  - @ngrx/effects;
  - @ngrx/component-store, а также нескольких предварительно настроенных конфигураций.
>Плагин поставляется с рядом правил, которые помогают устранять самые популярные злоупотребления NgRx. Правила настраиваются, так что вы можете выбрать те, которым вы хотите следовать, и какие правила должны выдавать ошибку или предупреждение.
>Некоторые правила также разрешают автоматические исправления с помощью ng lint --fix.

**level 4:** 
- Lighthouse — это автоматизированный инструмент с открытым исходным кодом, который можно запустить на любой веб-странице (общедоступной или требующей аутентификации) для улучшения качества этой страницы. Он может проводить аудит производительности, доступности, прогрессивных веб-приложений, SEO и многого другого на веб-странице. Lighthouse расскажет вам, насколько ваш веб-сайт соответствует стандартам Google. В отчете будут объяснены сильные и слабые стороны вашего сайта, а также предложены способы повысить его оценку.

- List of sections(Performance, accessibility, etc.) Lighthouse and short define:
  - Performance - рассчитывается на основе результатов теста скорости, сравнивая скорость вашего сайта с другими. Получение 100 баллов означает, что протестированная веб-страница работает быстрее, чем 98% или более веб-страниц. Оценка 50 означает, что страница работает быстрее, чем 75% Интернета (источник).
Когда вместо оценки отображается знак вопроса, это значит что некоторые запущенные тесты не были проведены должным образом и помечены как «Ошибка!».
  - Accessibility - Эти проверки подчеркивают возможности улучшения доступности вашего веб-приложения. Только часть проблем с доступностью может быть обнаружена автоматически, поэтому ручное тестирование также рекомендуется.
  - SEO - Эти проверки гарантируют, что ваша страница следует основным советам по поисковой оптимизации. Существует много дополнительных факторов, которые Lighthouse здесь не оценивает и которые могут повлиять на ваш поисковый рейтинг, в том числе производительность на Core Web Vitals.
  - Best practice - Эти проверки подчеркивают возможности улучшения общего состояния кода вашего веб-приложения. (использование устаревших бибиотек)
  - PWA - Progressive Web App - (Быстро и надежно, Устанавливаемый, Загрузка страницы недостаточно быстрая в мобильных сетях, Текущая страница не отвечает кодом 200 в автономном режиме, Не использует HTTPS, Не перенаправляет HTTP-трафик на HTTPS, Не имеет тега <meta name="viewport"> с шириной или начальным масштабом.)
  

---

# 51. Common. Patterns. Design Patterns (Factory, Module, Prototype, Observer, Builder, Facade, Decorator) (required level 4)

https://refactoring.guru/ru/design-patterns/what-is-pattern

**level 1:**  
-

**level 2:**  

- Understanding what programming patterns are and what problem they solve

> Паттерн проектирования — это часто встречающееся решение определённой проблемы при проектировании архитектуры программ.
> В отличие от готовых функций или библиотек, паттерн нельзя просто взять и скопировать в программу. Паттерн представляет собой не какой-то конкретный код, а общую концепцию решения той или иной проблемы, которую нужно будет ещё подстроить под нужды вашей программы.
> Если привести аналогии, то алгоритм — это кулинарный рецепт с чёткими шагами, а паттерн — инженерный чертёж, на котором нарисовано решение, но не конкретные шаги его реализации.

Зачем паттрены:

- Проверенные решения. Вы тратите меньше времени, используя готовые решения, вместо повторного изобретения велосипеда. До некоторых решений вы смогли бы додуматься и сами, но многие могут быть для вас открытием.
- Стандартизация кода. Вы делаете меньше просчётов при проектировании, используя типовые унифицированные решения, так как все скрытые проблемы в них уже давно найдены.
- Общий программистский словарь. Вы произносите название паттерна, вместо того, чтобы час объяснять другим программистам, какой крутой дизайн вы придумали и какие классы для этого нужны.

**level 3:**  

- Subtypes of programming patterns, name a few examples of each
  - Пораждающие -  беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей.
    - Factory method - Паттерн Фабричный метод предлагает создавать объекты не напрямую, используя оператор new, а через вызов особого фабричного метода. Не пугайтесь, объекты всё равно будут создаваться при помощи new, но делать это будет фабричный метод.
    - Abstract Factory - это порождающий паттерн проектирования, который позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.
    - Singletone
    
    
  - Структурные - показывают различные способы построения связей между объектами.
    - Facade -  это структурный паттерн проектирования, который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку. К примеру, программа, заливающая видео котиков в социальные сети, может использовать профессиональную библиотеку сжатия видео. Но все, что нужно клиентскому коду этой программы — простой метод encode(filename, format). Создав класс с таким методом, вы реализуете свой первый фасад.
    - Proxy
    - Decorator
    
  - Поведенческие - заботятся об эффективной коммуникации между объектами.
    - Observer - это поведенческий паттерн проектирования, который создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах. Паттерн Наблюдатель предлагает хранить внутри объекта издателя список ссылок на объекты подписчиков, причём издатель не должен вести список подписки самостоятельно. Он предоставит методы, с помощью которых подписчики могли бы добавлять или убирать себя из списка.
    - Iterator
    - Template method
 

**level 4:** 

- Facade, Observer, Factory - be able to write

---

# 52. Common. Debugging. App speed estimation, app debugging (required level 2)

**level 1:**  

- -Basic understanding of debugging process;

**level 2:**  

- Web-browser console usage;
- Work with breakpoints, types of  breakpoints;

**level 3:**  

- Networking, Google Lighthouse, redux devtools

**level 4:** 

- How we can measurement of speed of application
- https://web.dev/critical-rendering-path-measure-crp/

---

