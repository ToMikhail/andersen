[be back](https://github.com/ToMikhail/andersen)
___


https://habr.com/ru/company/vk/blog/283228/
# 1. Node.js API (required level 3)   

Node.js — не отдельный язык программирования, а платформа для использования JavaScript на стороне сервера. Если говорить о языке, то как для фронденда, так и для бэкенда используется один и тот же JavaScript. Разница только в наборе API, которые используют фронтендеры и бэкендеры.

   ***level 1:*** 
   
   - ***http module***. Basic understanding of http module, it's  purpose and details;
   ```
   const http = require('http)
   
   // create server
   const server = http.createServer((req, res) => {
   	console.log(req.url);
	
	res.write('<h1>Hello word from node JS</h1>')
	res.end()
   })
   
   //run server
   server.listen(3000, () => {
   	console.log('server is running')
   })
   ```
   
   - ***timers api***. Basics of timers api;
>Setting Node.js timer functions:   

>- setTimeout()
>- setInterval()
>- setImmediate();   

>Clearing Node.js timer functions
>- clearTimeout()
>- clearInterval()
>- clearImmediate() - функция setImmediate() будет запущена после завершения всего исполняемого кода. Функция setImmediate() запускает код после завершения текущего цикла цикла обработки событий. setImmediate() похож на setTimeout() с задержкой 0 мс.
>Other Node.js timer functions
>unref()
>ref()
   - difference between ***browser and node api***;
   >В браузере большую часть времени вы взаимодействуете с DOM или другими API-интерфейсами веб-платформы, такими как файлы cookie. Конечно, в Node.js их нет. У вас нет документа, окна и всех других объектов, предоставляемых браузером.
   >А в браузере у нас нет всех хороших API-интерфейсов, которые Node.js предоставляет через свои модули, таких как функциональность доступа к файловой системе.
   >Еще одно большое отличие заключается в том, что в Node.js вы контролируете среду. Если вы не создаете приложение с открытым исходным кодом, которое любой может развернуть где угодно, вы знаете, на какой версии Node.js вы будете запускать приложение. По сравнению со средой браузера, где вы не можете позволить себе роскошь выбирать, какой браузер будут использовать ваши посетители, это очень удобно.
   >Это означает, что вы можете написать весь современный JavaScript ES2015+, который поддерживает ваша версия Node.js. Поскольку JavaScript развивается так быстро, а браузеры могут немного медленно обновляться, иногда в Интернете вы застреваете на старых версиях JavaScript/ECMAScript. Вы можете использовать Babel для преобразования вашего кода в ES5-совместимый перед его отправкой в d браузер, но в Node.js вам это не понадобится.
   >Еще одно отличие состоит в том, что Node.js поддерживает системы модулей CommonJS и ES (начиная с Node.js v12), в то время как в браузере мы начинаем видеть реализацию стандарта модулей ES. На практике это означает, что вы можете использовать как require(), так и импорт в Node.js, в то время как вы ограничены импортом в браузере.
   
   ***level 2:***
   
   - Basics of file system api, how to work with files;    
   >есть два типа методоы: Synс и async. Sync не рекомендуется использовать(не блокирует поток). 
   
>	  *  fs.mkdir(path.join(__dirname, 'folder-name'), err => {}) - для создания папки.
>	  *  fs.writeFile(path.join(__dirname, 'folder-name'), err => {}) - для создания файла. Каждый раз файл бедт перезаписываться
>	  *  fs.appendFile(path.join(__dirname, 'folder-name'), err => {}) - для ставки контента в файл
>	  *  fs.writeFile(path.join(__diname, ''folder-name'', 'file-name.txt'), (err, data) => {}) - для чтения файлов. Данные приходят в буфере (часятим). Что бы полчить нормальный формат необходимо вторым прпметром указать кодировку 'utf-8', или трансформировать данные через метод Buffer.from(data).toString()
   
  ```
   fs.mkdir(path.join(__dirname, 'folder-name'), err => {
    if (err) throw new Error(err)
     console.log('папка создана')
     })
   ```
   
   
   - Understanding of Event Based approach, Events API   
   >При сиздании класса делаем extands EventEmmiter который под капотом имеет два метода on() и emmit(). 
   >Идея проста — объекты-эмиттеры отправляют именованные события, которые запускают уже зарегистрированных слушателей. Следовательно, объект-эмиттер имеет две ключевые характеристики:
  >* Генерация событий name: Сигнал о том, что что-то произошло, называется генерацией события. Причиной этого состояния часто является изменение состояния излучающего объекта. 
  >* Регистрация и отмена регистрации функций прослушивателя: это относится к привязке и отвязке функций обратного вызова с соответствующими им событиями.
  ```
  // Import the 'events' module
const events = require('events');

// Instantiate an EventEmitter object
const eventEmitter = new events.EventEmitter();

// Handler associated with the event
const connectHandler = function connected() {
	console.log('Connection established.');

	// Trigger the corresponding event
	eventEmitter.emit('data_received');
}

// Binds the event with handler
eventEmitter.on('connection', connectHandler);

// Binds the data received
eventEmitter.on(
	'data_received', function () {
		console.log('Data Transfer Successful.');
	});

// Trigger the connection event
eventEmitter.emit('connection');

console.log("Finish");
  ```
   
   ***level 3 (required):***
   
   - Basics of "process" and node js process module - Объект процесса предоставляет информацию о текущем процессе Node.js и управляет им. Объект процесса является экземпляром EventEmitter;
>process.pid: ID процесса этого экземпляра Node.
>process.versions: разные версии Node, V8 и других компонентов
>process.arch: архитектура системы
>process.argv: аргументы CLI
>process.env: переменные окружения

>Некоторые методы:

>process.uptime(): получает время работы
>process.memoryUsage(): получает объём потребляемой памяти
>process.cwd(): получает текущую рабочую папку. Не путать с __dirname, не зависящим от места, из которого был запущен процесс.
>process.exit(): выходит из текущего процесс. К примеру, можно передать код 0 или 1.
>process.on(): прикрепляет на событие, например, on(‘uncaughtException’)
>	 * Событие 'beforeExit' - Событие генерируется, когда Node.js очищает свой цикл событий и не имеет дополнительной работы для планирования. Обычно процесс >Node.js завершается, когда нет запланированной работы, но слушатель зарегистрирован на 'beforeExit' может выполнять асинхронные вызовы и тем самым вызывать продолжение процесса Node.js.
>	 * Событие: 'disconnect' - Если процесс Node.js порождается с каналом IPC (см. Дочерний процесс а также Кластер документация), 'disconnect' событие будет сгенерировано, когда канал IPC будет закрыт.
>	 * Событие: 'exit' - В 'exit' Событие генерируется, когда процесс Node.js собирается завершить работу в результате: 
>	- В process.exit() явно вызываемый метод;
>	- Цикл событий Node.js больше не требует дополнительной работы.


   - Basics of child process module, knowledge of creating/managing this processes;
>В child_process Модуль предоставляет возможность создавать подпроцессы аналогично, но не идентично popen (3). Эта возможность в первую очередь обеспечивается child_process.spawn() функция

   - Basics of Error and error handling for Node API;
>Приложения, работающие в Node.js, обычно сталкиваются с четырьмя категориями ошибок:

>* Стандартные ошибки JavaScript, такие как {EvalError}, {SyntaxError}, {RangeError}, {ReferenceError}, {TypeError} и {URIError}.
>* Системные ошибки, вызванные ограничениями базовой операционной системы, такими как попытка открыть несуществующий файл или попытка отправить данные через закрытый сокет.
>* Пользовательские ошибки, вызванные кодом приложения.
>* AssertionErrors - это особый класс ошибок, который может быть вызван, когда Node.js обнаруживает исключительное логическое нарушение, которое никогда не должно происходить. Обычно они поднимаются assert модуль.

>Ошибки, возникающие внутри Асинхронные API можно сообщить несколькими способами:

>* Большинство асинхронных методов, которые принимают callback функция примет Error объект, переданный в качестве первого аргумента этой функции. Если этот первый >аргумент не null и является экземпляром Error, то произошла ошибка, которую необходимо обработать.
>* Когда асинхронный метод вызывается для объекта, который является EventEmitter, ошибки могут быть перенаправлены на этот объект 'error' событие.
>* Некоторые обычно асинхронные методы в API Node.js могут по-прежнему использовать throw механизм для создания исключений, которые должны обрабатываться с помощью >try…catch. Исчерпывающего списка таких методов нет; обратитесь к документации по каждому методу, чтобы определить соответствующий требуемый механизм обработки ошибок.
   
   ***level 4:***
   
   - Basics of cluster module and it's practical usage; -
 > Один экземпляр Node.js работает в одном потоке. Чтобы воспользоваться преимуществами многоядерных систем, пользователь иногда может захотеть запустить кластер процессов Node.js для обработки нагрузки.
 > По умолчанию трубы для stdin, stdout, а также stderr устанавливаются между родительским процессом Node.js и порожденным подпроцессом. Эти трубы имеют ограниченную (и зависящую от платформы) пропускную способность. Если подпроцесс записывает в stdout сверх этого предела без захвата вывода, подпроцесс блокируется, ожидая, пока буфер канала примет больше данных. Это идентично поведению труб в оболочке. Использовать { stdio: 'ignore' } вариант, если выход не будет израсходован.
 > В child_process.spawn() метод асинхронно порождает дочерний процесс, не блокируя цикл событий Node.js. В child_process.spawnSync() Функция обеспечивает эквивалентную функциональность в синхронном режиме, которая блокирует цикл событий до тех пор, пока порожденный процесс не завершится или не завершится.
 > В child_process.spawn() метод асинхронно порождает дочерний процесс, не блокируя цикл событий Node.js. В child_process.spawnSync() Функция обеспечивает эквивалентную функциональность в синхронном режиме, которая блокирует цикл событий до тех пор, пока порожденный процесс не завершится или не завершится.

>Для удобства child_process модуль предоставляет несколько синхронных и асинхронных альтернатив child_process.spawn() а также child_process.spawnSync(). Каждая из этих альтернатив реализована поверх child_process.spawn() или child_process.spawnSync().

>child_process.exec(): порождает оболочку и запускает команду в этой оболочке, передавая stdout а также stderr в функцию обратного вызова по завершении.   
>child_process.execFile(): похожий на child_process.exec() за исключением того, что он порождает команду напрямую, без предварительного создания оболочки по умолчанию.   
>child_process.fork(): порождает новый процесс Node.js и вызывает указанный модуль с установленным каналом связи IPC, который позволяет отправлять сообщения между родителем и потомком.  

>child_process.execSync(): синхронная версия child_process.exec() который заблокирует цикл событий Node.js.
>child_process.execFileSync(): синхронная версия child_process.execFile() который заблокирует цикл событий Node.js.

>Модуль кластера позволяет легко создавать дочерние процессы, которые все используют порты сервера.

   - Basics of Streams API, where to use, specification of Streams;
 >Прежде чем начать обработку данных и/или выводить их, нам приходится ждать полной загрузки буфера. А теперь сравните это со схемой работы stream’ов. В этом случае мы можем сразу начать обрабатывать данные и/или выводить их, как только получим первый чанк:
 >В Node есть четыре типа stream’ов:
>* Читаемые (readable): из них можно читать.
>* Записываемые (writable): в них можно писать.
>* Дуплексные (duplex): можно и писать, и читать.
>* Stream’ы преобразования (transform): их можно использовать для преобразования данных.
>Виртуально stream’ы используются в Node повсеместно. Наиболее востребованные реализации stream’ов:

>* HTTP-запросы и отклики.
>* Стандартные операции ввода/вывода.
>* Чтение из файлов и запись в них.
	
> Для обеспечения шаблона “observer”, stream’ы — события — наследуют от объекта «эмиттер событий». Мы можем использовать это для реализации stream’ов.

___

# 2. Database (required level 3)

## 2.1 Tables, relationships, keys, constraints(required level 3)

>База данных — это упорядоченный набор структурированной информации или данных,

  ***level 1:***  
  
  ***level 2:***
  
  - Can give definitions "table", "field", "record"
  >- "table" - набор записей определенных типов. 
  >- "field" - относится к области внутри записи, которая зарезервирована для определенного фрагмента данных. Например. Идентификатор сотрудника.
  >- "record" - это набор значений или полей определенного объекта. Например. Сотрудник, зарплатный счет и т. д.
  
  ***level 3 (required):***
  
  - Can define the concept of "constraint", give examples + what is used for each
  > Ограничения — это, по сути, правила, которым должны подчиняться данные в таблицах. Они помогают обеспечить целостность данных.
  > Ограничения SQL используются для указания правил для данных в таблице.
  > Ограничения используются для ограничения типа данных, которые могут быть помещены в таблицу. Это обеспечивает точность и достоверность данных в таблице. Если есть какое-либо нарушение между ограничением и действием данных, действие прерывается.

>Следующие ограничения обычно используются в SQL:
>1. NOT NULL — гарантирует, что столбец не может иметь значение NULL.
>1. UNIQUE — гарантирует, что все значения в столбце различны. 
>2. ПPRIMARY KEY— комбинация NOT NULL и UNIQUE. Уникально идентифицирует каждую строку в таблице 
>3. FOREIGN KEY — предотвращает действия, которые разрушат связи между таблицами. 
>4. CHECK - Гарантирует, что значения в столбце удовлетворяют определенному условию. 
>5. DEFAULT — устанавливает значение по умолчанию для столбца, если значение не указано. 
>6. CREATE INDEX — используется для очень быстрого создания и извлечения данных из базы данных.

  ***level 4:***
  
  - Understanding the relationships between tables;
>relationship  между двумя таблицами базы данных предполагает, что одна из них имеет внешний ключ, ссылающийся на первичный ключ другой таблицы.

>В базе данных существует 3 основных типа отношений: 
>1. one-to-one - Данный тип связей встречает не часто. В этом случае объекту одной сущности можно сопоставить только один объект другой сущности. Например, на некоторых сайтах пользователь может иметь только один блог. То есть возникает отношение один пользователь - один блог.
>1. one-to-many - В этом типе связей несколько строк из дочерний таблицы зависят от одной строки в родительской таблице. Например, в одном блоге может быть несколько статей. В этом случае таблица блогов является родительской, а таблица статей - дочерней. То есть один блог - много статей. Или другой пример, в футбольной команде может играть несколько футболистов. И в то же время один футболист одновременно может играть только в одной команде. То есть одна команда - много футболистов.
>1. many-to-many - При этом типе связей одна строка из таблицы А может быть связана с множеством строк из таблицы В. В свою очередь одна строка из таблицы В может быть связана с множеством строк из таблицы А. Типичный пример - студенты и курсы: один студент может посещать несколько курсов, и соответственно на один курс могут записаться несколько студентов..
  - Knows how to organize all kinds of relationships
  
___

## 2.2 Creating, modifying, removing database objects: databases, tables, columns, indexes (required level 4)

  ***level 1:***  
  
  ***level 2:***
  
  -  Knowledge of commands for the listed operations;
>Оператор CREATE TABLE используется для создания новой таблицы в базе данных.
>- CREATE DATABASE - Оператор используется для создания новой базы данных SQL.
>- DROP TABLE используется для удаления существующей таблицы в базе данны
>- SELECT используется для выбора данных из базы данных.(SELECT column1, column2, ... FROM table_name;)
>- INSERT INTO используется для вставки новых записей в таблицу. INSERT INTO table_name (column1, column2, column3, ...) VALUES (value1, value2, value3, ...);
>- DELETE Оператор DELETE используется для удаления существующих записей в таблице. DELETE FROM table_name WHERE condition;
>- ALTER TABLE используется для добавления, удаления или изменения столбцов в существующей таблице.
>- ADD используется для добавления столбца в существующую таблицу.ALTER TABLE Customers ADD Email varchar(255);
>- ALTER TABLE - DROP COLUMN - Чтобы удалить столбец в таблице, используйте следующий синтаксис (обратите внимание, что некоторые системы баз данных не позволяют удалять столбец): ALTER TABLE table_name DROP COLUMN column_name;
>- ALTER TABLE - RENAME COLUMN - ALTER TABLE table_name RENAME COLUMN old_name to new_name;


  ***level 3 (required):***
  
  - Knowledge of syntax + ability to solve problems for these operations

  ***level 4:***
  
  - Understanding indexes;
  >CREATE INDEX используется для создания индексов в таблицах.
  >Индексы используются для более быстрого извлечения данных из базы данных. Пользователи не могут видеть индексы, они просто используются для ускорения поиска/запросов.
  >Обновление таблицы с индексами занимает больше времени, чем обновление таблицы без индексов (поскольку индексы также нуждаются в обновлении). Поэтому создавайте индексы только для тех столбцов, по которым будет часто выполняться поиск.
  >CREATE INDEX index_name ON table_name (column1, column2, ...);
  >The DROP INDEX statement is used to delete an index in a table.

  - What the indexes are used for;
  - How indexes work
  >Индексация — это способ сортировки ряда записей по нескольким полям. Создание индекса для поля в таблице создает другую структуру данных, которая содержит значение поля и указатель на запись, к которой оно относится. Затем эта структура индекса сортируется, что позволяет выполнять в ней двоичный поиск.
  
___

## 2.3 Data manipulation (insert, update, delete) (required level 4)

  ***level 1:***  
  
  ***level 2:***
  
  -  Knowledge of operator groups (DML, DCL, TCL, DDL)
 >1. Data Definition Language(DDL) - которые можно использовать для разработки структуры базы данных.:
 > * CREATE Command - Эта команда создает базу данных или ее объекты (такие как таблица, индекс, функция, представления, процедура хранения и триггеры). В SQL есть два типа операторов CREATE: один для создания базы данных, а другой для таблицы.
 > 
 > ```
 > Syntax: CREATE DATABASE db_name;
 > db_name : name of the database(any name can be given) 
 >
 > Example: CREATE TABLE Employee(Emp_Name VARCHAR2(20), DOB DATE, Mobile INT(10), Email VARCHAR2(20));
 >  ```
 > * DROP Command - может использоваться для удаления всей базы данных или просто таблицы, что означает, что все данные также будут удалены. Оператор DROP удаляет существующие объекты, такие как базы данных, таблицы, индексы и представления.
 >  ```
 >  Syntax: For dropping table: DROP TABLE table_name;
 >  For dropping database: DROP DATABASE db_name;
 >  ```
 > * ALTER Command - В существующей таблице эта команда используется для добавления, удаления/удаления или редактирования столбцов. Его также можно использовать для создания и удаления ограничений из уже существующей таблицы.
 >  ```
 >  To add a new column:
 > Syntax: ALTER TABLE table_name ADD column_name COLUMN-definition;
 > Example: ALTER TABLE Employee ADD Address VARCHAR2(20);
 > 
 > To modify the existing column:
 > Syntax: ALTER TABLE MODIFY(COLUMN DEFINITION….);
 > Example: ALTER TABLE Employee MODIFY(Emp_Name VARCHAR2(25));
 . The above command will modify the ‘Emp_Name’ column to data type VARCHAR2 with size 25.
 >  ```
 > * TRUNCATE Command - используется для указания экстентов таблицы для освобождения (пусто для повторного использования). Эта процедура быстро удаляет все данные из таблицы, обычно обходя ряд процессов проверки целостности. Он впервые был включен в стандарт SQL:2008. Это несколько эквивалентно команде удаления.
 >  ```
 >  Syntax: TRUNCATE TABLE  table_name;
 > Example: TRUNCATE TABLE Employee;

 > The above command will delete the data from the ‘Employee’ table but not the table.
 >  ```

 > 2. DML (Data Manipulation Language) - Это часть инструкции SQL, которая регулирует, кто имеет доступ к данным и базе данных. Операторы DCL сгруппированы вместе с операторами DML. Команда DML не фиксируется автоматически, что означает, что она не может постоянно сохранять все изменения базы данных. У них есть возможность откатиться назад.
 > * INSERT Command - Используется для вставки данных в строку таблицы.:
 > ```
 > Example: INSERT INTO Employee(Emp_Name, DOB, Mobile, Email)
 > VALUES(‘Joe’, ‘1995-02-16’, 7812865845, ‘joe@gmail.com’);
 >The above command will insert the mentioned values in the ‘Employee’ table.
 > ```
 > * UPDATE Command - используется для обновления данных в существующей таблице базы данных. Мы можем использовать оператор Alter для обновления одного или нескольких столбцов в зависимости от наших потребностей.
 >  ```
 > Example: UPDATE Employee SET Mobile=9935467903 WHERE Emp_Name=’Joe’;
 > ```
 > Оператор SET используется в приведенном выше запросе для присвоения новых значений определенному столбцу, а предложение WHERE используется для выбора строк, для которых необходимо изменить столбцы. Если мы не используем предложение WHERE, все столбцы строк будут обновлены. В результате предложение WHERE используется для выбора определенных строк.
 > * DELETE Command - используется для удаления записей из таблицы. В зависимости от условия, которое мы установили в предложении WHERE, мы можем удалить одну запись или несколько записей.
 > ```
 > Example: DELETE FROM Employee WHERE Emp_Name=’Joe’;
 > ```
 > 3. Data Control Language(DCL)- позволяет пользователям извлекать и редактировать данные, хранящиеся в базах данных. Типы команд языка управления данными включают Grant и Revoke.
 > * GRANT Command - Эта команда дает права доступа пользователя к базе данных. Его можно использовать для предоставления привилегий SELECT, INSERT, UPDATE и DELETE пользователю в одной или нескольких таблицах.
 > ```
 > Example: GRANT INSERT, SELECT on accounts to Alex
 > ```
 > С помощью этой команды Алексу были предоставлены разрешения на объекты базы данных учетных записей, такие как он может запрашивать или вставлять в учетные записи.
 > * REVOKE Command - Чтобы отозвать разрешения у пользователя, используется команда REVOKE. Он используется для отзыва привилегии (по умолчанию) или конкретной команды, такой как UPDATE или DELETE, в зависимости от ситуации.:
 > ```
 > Example: REVOKE INSERT, SELECT on accounts from John
 > ```
 > С помощью этой команды были удалены разрешения Джона, такие как запрос или вставка в объекты базы данных учетных записей.
 > 4.Transaction Control Language(TCL) - используются в базе данных для управления транзакциями. Эта команда используется для обработки модификаций операторов DML. TCL позволяет объединять ваши операторы в логические транзакции.
 > * COMMIT Command - Для сохранения всех транзакций в базе данных используется Commit.
 > ```
 > Example: UPDATE Employee SET DOB=’1995-02-17’ WHERE Emp_Name=’Joe’;
 > COMMIT;
This example will insert the dob in the table which have name = Joe and then COMMIT the changes in the database.
 > ```
 > * ROLLBACK Command - Все изменения должны быть отменены, если какой-либо из сгруппированных операторов SQL приводит к ошибке. Термин «откат» относится к процессу отмены изменений. Эту команду можно использовать только для отмены транзакций, которые произошли после последней команды COMMIT или ROLLBACK.
 > ```
 > Example: UPDATE Employee SET DOB=’1995-02-17’ WHERE Emp_Name=’Joe’;
 > ROLLBACK;
 >  Этот пример вставит доб в таблицу с именем = Джо, а затем отменит изменения в базе данных. Таким образом, эта операция не повлияет на таблицу.
 > ```
 >
 > * SAVEPOINT Command - для отката транзакции до определенной точки, а не для полной транзакции. Среди всех транзакций эта команда используется исключительно для создания SAVEPOINT.
 > ```
 > Example: SAVEPOINT S1; //savepoint created
 > DELETE FROM Employee WHERE Emp_Name = ‘Joe’; //deleted 
 > SAVEPOINT S2; //Savepoint created.
 > ```


  ***level 3 (required):***
  
  - Knowing what each operator is used for


  ***level 4:***
  
  - Knowledge of the syntax for operators;
  - Give examples of use (task)
  
  
___

## 2.4 Retrieving data (simple select statement) (required level 3)

  ***level 1:***  
  
  - What is a request;
  - How is it initialized


  ***level 2:***
  
  - Give an example in practice of how a request is made (with / without a condition)


  ***level 3 (required):***
  
  - Give an example of sampling with multiple conditions

  ***level 4:***
  
  - Knowledge of subqueries;
  - Give an example of a selection with a subquery


___

## 2.5 "Transactions" (required level 2)

  ***level 1:***  
  
  - What is a transaction;
  - Transaction concepts (ACID)


  ***level 2:***
  
  - Knowledge of the commands used for the transaction


  ***level 3 (required):***
  
  - GGive a practical example of a transaction


  ***level 4:***
  
  - Transaction isolation levels
___

## 2.6 CRUD concept (required level 4)

  ***level 1:***  
  
  -
  ***level 2:***
  
  -  
  ***level 3 (required):***
  
  - 

  ***level 4:***
  
  - значение CRUD. Соотношение операций акронима с SQL опреаторами


___


